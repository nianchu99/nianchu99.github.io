<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>nianchu-Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="nianchu-Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;www.nianchu.space&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="nianchu-Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="nianchu-Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">nianchu-Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.nianchu.space"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Swift/Swift Programming Language Book/Swift初见" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/16/Swift/Swift%20Programming%20Language%20Book/Swift%E5%88%9D%E8%A7%81/" class="article-date">
  <time datetime="2020-05-15T16:36:44.954Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/16/Swift/Swift%20Programming%20Language%20Book/Swift%E5%88%9D%E8%A7%81/">Swift/Swift Programming Language Book/Swift初见</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Swift初见"><a href="#Swift初见" class="headerlink" title="Swift初见"></a>Swift初见</h1><h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>使用let来宣告常数，使用var来宣告变数</p>
<p>常数或者变数的型别必须和你赋给它们的值一样。但是不一定在声明的时候显示声明类型，因为编译器会自动推断类别。</p>
<p>如果初始值没有提供足够的资讯(或者没有初始值)，就需要在变数后面宣告类型，用冒号分隔，例如：<br>let implicitDouble = 70.0<br>let explicitDouble: Double = 70</p>
<p>值永远不会被隐式转换为其他类别。如果需要对值进行转换，需要显示转换 例如：<br>let label = “The width is “<br>let width = 94<br>let widthLabel = label + String(width)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/05/16/Swift/Swift%20Programming%20Language%20Book/Swift%E5%88%9D%E8%A7%81/" data-id="ckb0u8cjv005xqgubboip8v1k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/JavaFX基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/07/Java/JavaFX%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-05-07T00:35:07.899Z" itemprop="datePublished">2020-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/07/Java/JavaFX%E5%9F%BA%E7%A1%80/">Java/JavaFX基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaFX基础"><a href="#JavaFX基础" class="headerlink" title="JavaFX基础"></a>JavaFX基础</h1><h1 id="javaFX是学习面向对象编程的优秀教学工具"><a href="#javaFX是学习面向对象编程的优秀教学工具" class="headerlink" title="javaFX是学习面向对象编程的优秀教学工具"></a>javaFX是学习面向对象编程的优秀教学工具</h1><h2 id="JavaFX与Swing以及AWT的比较"><a href="#JavaFX与Swing以及AWT的比较" class="headerlink" title="JavaFX与Swing以及AWT的比较"></a>JavaFX与Swing以及AWT的比较</h2><p>要点提示： JavaFX用于开发富因特网应用</p>
<p>富因特网应用是一种Web应用，可以表现一般桌面应用具有的特点和功能。JavaFX可以无缝地在桌面或者Web浏览器中运行。</p>
<h2 id="JavaFX程序的基本结构"><a href="#JavaFX程序的基本结构" class="headerlink" title="JavaFX程序的基本结构"></a>JavaFX程序的基本结构</h2><p>要点提示 ： 抽象类 javafx . application . Application 定义编写 JavaFX 程序的基本框架 。</p>
<h2 id="面板、UI组件以及形状"><a href="#面板、UI组件以及形状" class="headerlink" title="面板、UI组件以及形状"></a>面板、UI组件以及形状</h2><p>要点提示： 面板、UI组件以及形状是Node的子类型<br><img src="media/15888212935424.jpg" alt="-w247"><br>(各个部分的包含情况)</p>
<h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><p>要点提示： 可以将一个目标对象绑定到源对象中。源对象的修改将自动反应到目标对象中。</p>
<p>属性绑定： 将一个目标对象和一个源对象绑定。如果源对象中的值改变了，目标对象也将自动改变。目标对象称为绑定对象或者绑定属性，源对象称为可绑定对象或者可观察属性。</p>
<p>一个属性既可以作为目标，也可以作为源。目标监听源中的变换，一旦源中发生变化，目标将自动更新自身。<br>一个目标采用bind方法和源进行绑定，如下所示：<br>target.bind(source);<br><img src="media/15888260461998.jpg" alt="-w660"><br>绑定的演示：<br><img src="media/15888263948826.jpg" alt="-w667"></p>
<p><strong><em>双向绑定</em></strong><br>这样，一个属性的改变将反应到另一个对象上，反过来也一样，这样的绑定叫做双向绑定。如果目标和源同时是绑定属性和可观察熟悉你个，他们就可以使用bindBidirectional方法进行双向绑定。</p>
<h2 id="节点的通用属性和方法"><a href="#节点的通用属性和方法" class="headerlink" title="节点的通用属性和方法"></a>节点的通用属性和方法</h2><p>要点提示： 抽象类Node定义来许多对于节点而言通用的属性和方法<br>节点具有通用属性；<br>JavaFx的样式属性称为JavaFx CSS</p>
<p>设定样式的语法是styleName:value<br>一个节点的多个属性可以一起设置，通过分号(;)进行分隔。例如：<br>circle.setStyle(“-fx-stroke: black; -fx-fill: red”);<br>它等效于:<br>circle.setStyle(Color.Black);<br>circle.setFill(Color.Red);<br><em>如果使用了一个不正确的JavaFx CSS，程序依然可以编译和运行，但是样式会被忽略</em></p>
<p>rotate属性可以设定一个以度为单位的角度，让节点围绕它的中心旋转该角度。如果设置的角度是正的，表示顺时针旋转，否则是逆时针旋转<br>例如：将一个按钮旋转80度<br>button.setRotate(80);</p>
<h2 id="Color类"><a href="#Color类" class="headerlink" title="Color类"></a>Color类</h2><p>要点提示： Color类可以用于创建颜色</p>
<p>JavaFx定义类抽象类Paint用于绘制节点。Javafx.scene.paint.Color是Paint的具体子类，用于封装颜色信息。具体如下：<br><img src="media/15894177223880.jpg" alt="-w1051"><br>可以通过一下构造方法创建颜色实例：<br>public Color(double r, double g, double b, double opacity);其中的每个double值的范围从0.0到1.0,由浅到深。opacity定义了一个颜色的透明度，也是从0.0到1.0，由完全透明到完全不透明。这称为RGB模型，A表示alpha值，是透明度的意思。</p>
<p>Color color = new Color(0.25, 0.14, 0.333, 0.51);<br>Color类是不可修改的。当一个Color对象创建后，它的属性就不能再修改。brighter()返回一个具有更大的红、绿、蓝值的新的Color对象，而darker()方法返回一个具有更小的对象，opacity值与原来的Color对象中的值相同。</p>
<p>采用静态方法color(r,g,b),color(r,g,b,opacity),rgb(r,g,b),rgb(r,g,b,opac ity)来创建一个颜色对象。</p>
<p>另外一种方法是： 可以采用Color类中定义的许多标准颜色之一，如BEIGE(米色),BLACK,BLUE,CYAN,DARKGRAY,GREEN,LIGHTGRAY,MAGENTA(品红)，NAVY(海军蓝),ORANGE,PINK,SILVER,WHITE,YELLOW</p>
<h2 id="Font类"><a href="#Font类" class="headerlink" title="Font类"></a>Font类</h2><p>要点提示： Font类描述字体名、粗细和大小<br>可以在渲染文字的时候设置字体信息。javafx.scene.text.Font类用于创建字体<br><img src="media/15894186146809.jpg" alt="-w1156"></p>
<p>Font类实例可以用它的静态方法或者哦构造方法来创建，Font可以用它的名字、粗细、字体形态和大小来描述。Times,Courier和Arial是字体名字的示例。可以通过调用静态方法getFamilies()获得一个可用的字体系列名字列表。List是一个为列表定义通用方法的接口。ArrayList是List的一个具体实现。</p>
<p>字体形态是两个常量：FontPosture.ITALTC(意大利文)和FONTPosture.REGULAR.下面语句生成两个字体。<br>Font font1 = new Font(“SansSerif”,16);<br>Font font2 = Font.font(“Times New Roman “,FontWeight.BOlD, FontPosture.ITALIC, 12)<br><strong>StackPane将节点置于中央，节点依次位于最上面</strong></p>
<h2 id="Image和ImageView类"><a href="#Image和ImageView类" class="headerlink" title="Image和ImageView类"></a>Image和ImageView类</h2><p>要点提示： Image类表示一个图像，ImageView用于显示一个图像。</p>
<p>javafx.scene.image.Image类表示一个图像，用于从一个特定的文件名或者一个URL载入一个图像。</p>
<p>javafx.scene.image.ImageView是一个用于显示图像的节点。ImageView可以从一个Image对象产生。例如：以下代码从一个图像文件创建一个ImageView:<br>Image image = new Image(“image/us.gif”);<br>ImageView imageView = new ImageView(image);</p>
<p>当然，也可以周姐从一个文件或者一个URL来创建一个ImageView</p>
<p><img src="media/15894210170447.jpg" alt="-w1099"><br><img src="media/15894210336726.jpg" alt="-w1176"></p>
<p>HOX是一种面板，他将所有的节点排列在水平的一行上。<br>seRoate方法在Node类中定义，可以用于任何节点。<br>Image对象可以被多个节点共享。<br>ImageView这样的节点是不能共享的。不能讲一个ImageView多次放入一个面板或者场景中。<br><strong>注意</strong>，务必将图像文件放在类文件的相同个目录中。</p>
<p>如果使用URL来定位图像文件，必须提供URL协议http://</p>
<p>pane.setPadding(new Insets(5, 5 ,5, 5)); // 用于设置节点到边缘的距离</p>
<h2 id="布局面板"><a href="#布局面板" class="headerlink" title="布局面板"></a>布局面板</h2><p>要点提示：  javafx提供了许多种类型的面板，用于自动地将节点布局在希望的位置和大小。面板的种类有下面这些。</p>
<p><img src="media/15894387106951.jpg" alt="-w1118"></p>
<p>Pane通常用作显示形状的画布。</p>
<p>Pane是所有特定面板的基类。</p>
<p>特定的面板StackPane。节点放置在StackPane面板的中央。</p>
<h3 id="FlowPane"><a href="#FlowPane" class="headerlink" title="FlowPane"></a>FlowPane</h3><p> FlowPane 将节点按照加入的次序，从左到右或者从上到下垂直组织。当一行或者一列排满的时候，开始新的一行或者一列。可以使用下面两个常数中的一个来确定节点是水平还是垂直排列：<br> Orientation.HORIZONTAL 或者 Orientation.VERTICAL。（默认是水平的）可以使用像素为单位指定节点之间的距离。FlowPane的类图如图所示：<br> <img src="media/15894392532482.jpg" alt="-w1066"></p>
<p>其中数据域alignment、oritentation、hap和vgap是绑定属性。JavaFX中的每个绑定属性都有一个获取方法，例如getHgap()返回其值，一个设置方法，如sethGap(double)设置一个值，以及一个获取方法返回属性本身，(如hGapProperty())。对于一个ObjectProperty<T>类型的数据值，值的获取方法返回一个T类型的值，属性获取方法返回一个ObjectProperty<T>类型的属性值。</p>
<p><strong>文本域这样的节点只能加到一个面板中一次。将一个节点加入到一个面板中多次或者不同面板中将引起运行时错误</strong></p>
<p>一个节点只能放置在一个面板中。因此，面板和节点的关系是组合关系，使用一个填充的菱形表示。</p>
<h3 id="GridPane"><a href="#GridPane" class="headerlink" title="GridPane"></a>GridPane</h3><p>GridPane将节点布局在一个网络(矩阵)中。节点放在一个指定的列和行索引中。GridPane的类图如下：<br><img src="media/15894418799041.jpg" alt="-w1203"></p>
<p><strong>注意</strong><br>场景的大小没有设置时，场景会根据其中节点的大小自动计算。</p>
<h3 id="BorderPane"><a href="#BorderPane" class="headerlink" title="BorderPane"></a>BorderPane</h3><p>BorderPane可以将节点放置在五个区域： 顶部、底部、左边、右边以及中间，分别使用：<br>setTop(node), setBottom(node),setLeft(node),setRight(node),setCenter(node)<br><img src="media/15895503639516.jpg" alt="-w1077"></p>
<p><strong>注意</strong><br>面板自己就是一个节点，所以面板可以加入到另一个面板中。<br>如果要将一个节点从顶部区域移除，调用setTop(null);<br>如果一个区域没有被占据，那么不会分配空间给这个区域</p>
<h3 id="HBox和VBox"><a href="#HBox和VBox" class="headerlink" title="HBox和VBox"></a>HBox和VBox</h3><p>HBox将它的字节点布局在单个水平行中。VBox将它的节点布局在单个垂直列中。<br>和FlowPane想比，HBox和VBox只能将节点布局在一行或者一列中，而不是将它的额节点布局在多行或者多列中。<br><img src="media/15895513038688.jpg" alt="-w1162"><br><img src="media/15895513685595.jpg" alt="-w1110"></p>
<h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><p>JavaFx提供了多种形状类，用于绘制文本、直线、圆、矩形、椭圆、弧、多边形以及折线<br>Shape类是一个抽象基类，定义了所有形状的共有属性。这些属性有fill，stroke，strokeWidth。</p>
<p>fill指定一个填充形状内部区域的颜色<br>stroke指定用于绘制形状边缘的颜色。<br>strokeWidth指定形状边缘的宽度。</p>
<p><img src="media/15896010726056.jpg" alt="-w761"></p>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text类定义类一个节点，用于在一个起始点(x,y)处显示一个字符串。<br>Text对象通常置于一个面板中。</p>
<p>对于一个面板，左上角是(0,0),右下角是(pane.getWidth(),pane.getHeight())</p>
<p>一个字符串可以通过\n分隔从而显示在多行。<br>以下是Text的UML图：<br><img src="media/15896012798009.jpg" alt="-w1165"></p>
<h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><p>一条线通过4个参数(startX, startY, endX, endY)连接两个点。Line类的UML图：<br><img src="media/15896020888659.jpg" alt="-w1116"></p>
<h3 id="Rectangle"><a href="#Rectangle" class="headerlink" title="Rectangle"></a>Rectangle</h3><p>一个矩形通过参数x, y, width, height, arcWidth以及arcHeight定义。<br>矩形的左上角处于(x,y),参数aw(arcWidth)表示圆角处弧的水平直径，ah(arcHeight)表示圆角处弧的垂直直径。Rectangle的UML图如下：<br><img src="media/15896042504197.jpg" alt="-w1199"></p>
<h3 id="Circle和Ellipse-椭圆"><a href="#Circle和Ellipse-椭圆" class="headerlink" title="Circle和Ellipse(椭圆)"></a>Circle和Ellipse(椭圆)</h3><p><img src="media/15896958010306.jpg" alt="-w1112"><br>对于Ellipse,其中的radiusX值的是a，radiusY指的是b(椭圆数学定义中的a和b)</p>
<h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h3><p>一段弧可以认为是椭圆的一部分，由参数centerX, centerY, radiusX, radiusY, startAngle, length以及一个弧的类型(ArcType.OPEN, ArcType.CHORD或者ArcType.ROUND)来确定。 </p>
<p>其中startAngle是起始角度，length是跨度(即弧所覆盖的角度)。</p>
<p>角度使用度来作为单位，并且遵循通常的数学约定(即，0度是最东的方向，正的方向表示从最东方向开始顺时针方向的旋转角度)<br><img src="media/15897048959125.jpg" alt="-w1188"><br>单词解释： chord - 弦<br>不同类型弧长如下 ：<br><img src="media/15897049914944.jpg" alt="-w530"></p>
<p>角度可以是负数。一个负的起始角度从最东的方向顺时针旋转一个角度。一个负的跨度角度从起始角度开始顺时针旋转一个角度<br>（一句话总结： 这里的正负就和数学中一样）</p>
<h3 id="Polygon-多边形-和polyline-折线"><a href="#Polygon-多边形-和polyline-折线" class="headerlink" title="Polygon(多边形)和polyline(折线)"></a>Polygon(多边形)和polyline(折线)</h3><p>Polygon类定义一个连接一个点序列的多边形，polyline类类似于Polygon类，不同之处是Polyline类不会自动闭合。分别如下图所示：<br><img src="media/15897063079146.jpg" alt="-w1178"></p>
<p><img src="media/15897063195567.jpg" alt="-w1169"></p>
<h2 id="示例学习：-ClockPane-类"><a href="#示例学习：-ClockPane-类" class="headerlink" title="示例学习： ClockPane 类"></a>示例学习： ClockPane 类</h2><p>要点提示： 学习开发一个类，在面板中显示一个始终<br>ClockPane的合约图如下<br><img src="media/15897840550956.jpg" alt="-w1058"></p>
<p>因为一分钟有60s，所以第二个指针的角度是:<br>second * (2*pi/60)<br>包含秒数的确切分钟数是(minute + second / 60)</p>
<p>因为一小时有60分，因此分针的角度是(minute + second / 60) * (2pi/60)</p>
<p>由于一个圆被分为12个小时，所以时针的角度是： (hour + minute / 60 + second / (60 + 60)) * (2pi/12)<br><img src="media/15897845812196.jpg" alt="-w1163"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/05/07/Java/JavaFX%E5%9F%BA%E7%A1%80/" data-id="ckb0u8chc0020qgub7wxl0oeb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-引用数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/Java/Java-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2020-05-04T14:16:58.434Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/Java/Java-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Java/Java-引用数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-引用数据类型与基本数据类型"><a href="#Java-引用数据类型与基本数据类型" class="headerlink" title="Java-引用数据类型与基本数据类型"></a>Java-引用数据类型与基本数据类型</h1><p><img src="media/15886035121002.jpg" alt="-w1012"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/05/04/Java/Java-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="ckb0u8ch4001sqgubf6th4nmf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-黑马教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/30/Java/Java-%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B/" class="article-date">
  <time datetime="2020-04-30T05:56:40.257Z" itemprop="datePublished">2020-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/Java/Java-%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B/">Java/Java-黑马教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-黑马教程"><a href="#Java-黑马教程" class="headerlink" title="Java-黑马教程"></a>Java-黑马教程</h1><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>硬盘： 永久存储<br>内存： 临时存储</p>
<p>I： input输入，读取<br>O： output输出，写入<br>流： 数据(字符，字节)<br>1字符=2字节=<br>1字节=8个二进制位（即8个byte）</p>
<p>输入：把硬盘中的数据读取到内存中使用<br>输出 ：把内存中的数据写入到硬盘中保存<br><img src="media/15882264874443.jpg" alt="-w1448"></p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>一切文件数据（文本、图片、视频）都是以字节方式存储的。<br>所以，字节流可以传输任意文件数据，在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终是二进制数据</p>
<h4 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a>OutputStream 字节输出流</h4><p>此抽象类是表示输出字节流的所有类的超类<br>定义了一些子类共性的成员方法。</p>
<h5 id="FileOutputStream-文件字节输出流"><a href="#FileOutputStream-文件字节输出流" class="headerlink" title="FileOutputStream 文件字节输出流"></a>FileOutputStream 文件字节输出流</h5><p>作用： 把内存中的数据写入到硬盘的文件中</p>
<p>构造方法： </p>
<p>FileOutputStream(File file)<br>          创建一个向指定 File 对象表示的文件中写入数据的文件输出流。<br>FileOutputStream(String name)<br>          创建一个向具有指定名称的文件中写入数据的输出文件流。</p>
<p>参数： 写入数据的目的地<br>string name：目的地是一个文件的路径<br>File file： 目的地是一个文件<br>构造方法的作用： </p>
<ol>
<li>创建一个FileOutputStream对象</li>
<li>会根据构造方法中传递的文件/文件路径，创建一个空的文件</li>
<li>会把FileOutputStream对象只想创建好的文件</li>
</ol>
<h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><p>原理：如果 内存 -&gt; 硬盘<br>java程序 — JVM（java虚拟机）— OS（操作系统）— OS调用写数据的方法 — 把数据写入到文件</p>
<p>字节流的使用步骤(重点)</p>
<ol>
<li>创建一个FIleOutputStream对象，构造方法中传入数据的目的地</li>
<li>调用FIleOutputStream对象中的方法write，把数据写入到文件中</li>
<li>释放资源（这样可以节约内存，因为流的使用会占用一定的内存）</li>
</ol>
<p><strong><em>文件存储的原理和记事本打开</em></strong><br>写数据的时候会把十进制的整数转换为二进制的整数</p>
<p>记事本在打开文件的时候都会查询编码表，把字节转换为字符表示，故如果写入为：<br>0-127 - 查询ASCII表<br>其他值：会查询系统默认码表（中文系统GBK）<br><img src="media/15882290494697.jpg" alt="-w1433"></p>
<h6 id="一次写多个字节的方法"><a href="#一次写多个字节的方法" class="headerlink" title="一次写多个字节的方法"></a>一次写多个字节的方法</h6><p><img src="media/15882291991446.jpg" alt="-w706"><br>第一个：<br>用于一次写多个字节：</p>
<ul>
<li>如果写的第一个字节是正数（0-127），那么显示的时候会查询ASCII表</li>
<li>如果写的第一个字节是负数，那么第一个字节会和第二个字节，连个字节组成一个中文显示，查询系统默认码表（GBK）</li>
</ul>
<p>第二个用来写字节数组的一部分：<br>int off: 数组的开始索引<br>int len: 写几个字节</p>
<p>另外一种写入字符的方法：<br>使用String类中的方法把字符串，转换为字节数组</p>
<h6 id="数据的续写和换行写"><a href="#数据的续写和换行写" class="headerlink" title="数据的续写和换行写"></a>数据的续写和换行写</h6><p>续写即追加写</p>
<p>构造方法：<br>FileOutputStream(String name, boolean append)<br>          创建一个向具有指定 name 的文件中写入数据的输出文件流。<br>          FileOutputStream(File file, boolean append)<br>          创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</p>
<p>参数：<br>String name，File file ： 写入数据的目的地<br>boolean append： 续写开关</p>
<ul>
<li>true： 继续在文件末尾续写数据</li>
<li>false： 创建一个新文件，覆盖</li>
</ul>
<p>换行写，写完数据之后写上换行符号</p>
<h4 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a>InputStream 字节输入流</h4><p>方法：<br>    int read()<br>          从此输入流中读取下一个数据字节。<br>int    read(byte[] b)<br>从此输入流中将 byte.length 个字节的数据读入一个 byte 数组中。<br>void    close()<br>          关闭此输入流并释放与此流关联的所有系统资源。</p>
<h5 id="FileinputStream-文件字节输入流"><a href="#FileinputStream-文件字节输入流" class="headerlink" title="FileinputStream 文件字节输入流"></a>FileinputStream 文件字节输入流</h5><p><img src="media/15882331045281.jpg" alt="-w354"></p>
<p>作用： 把硬盘文件中的数据，读取到内存中使用</p>
<p>构造方法：<br><img src="media/15882332509769.jpg" alt="-w1110"></p>
<p>参数：<br>读取文件的数据源<br>String name:文件的路径<br>File file: 文件<br>构造方法的作用：</p>
<ol>
<li><p>会创建一个FileInputStream对象</p>
</li>
<li><p>会把FileInputStream对象指向构造方法中要读取的文件</p>
<p>读取数据的原理：<br>原理：如果 硬盘 -&gt; 内存<br>java程序 — JVM（java虚拟机）— OS（操作系统）— OS调用读数据的方法 — 读入文件<br>使用步骤：</p>
<ol>
<li>创建一个FileInputStream对象，构造方法中绑定要读取的数据</li>
<li>使用FileInputStream对象中的方法read，读取文件<br>int read()读取文件中的一个字节并返回，读取到文件的末尾返回-1</li>
<li>释放资源</li>
</ol>
</li>
</ol>
<p><strong><em>注意</em></strong><br>不知道文件中有多少字节，使用while循环<br>boolean表达式：while((len = fis.read())!= -1){<br>}<br>实际过程：<br>int len;<br>len = fis.read();<br>len = fis.read())!= -1</p>
<p>而不能写成：<br>while((fis.read())!= -1){<br>System.out.println(fis.read())<br>}</p>
<p> <strong><em>方法</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/30/Java/Java-%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B/" data-id="ckb0u8chb001yqgubca8g905e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-郑莉版输入输出流课件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/30/Java/Java-%E9%83%91%E8%8E%89%E7%89%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%AF%BE%E4%BB%B6/" class="article-date">
  <time datetime="2020-04-30T01:36:46.332Z" itemprop="datePublished">2020-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/Java/Java-%E9%83%91%E8%8E%89%E7%89%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%AF%BE%E4%BB%B6/">Java/Java-郑莉版输入输出流课件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="郑莉版输入输出流课件"><a href="#郑莉版输入输出流课件" class="headerlink" title="郑莉版输入输出流课件"></a>郑莉版输入输出流课件</h1><p>在Java中将信息的输入与输出过程抽象为I/O流<br>I/O流一旦被创建就会自动打开<br>通过调用close方法，可以显式关闭任何一个流<br>如果流对象不再被引用，Java的回收机制也会隐式地关闭它<br><img src="media/15882111044109.jpg" alt="-w687"></p>
<h2 id="读写数据的方法"><a href="#读写数据的方法" class="headerlink" title="读写数据的方法"></a>读写数据的方法</h2><p>不论数据从哪来，到哪去，也不论数据本身是何种类型，读写数据分方法大体上都是一样的<br><img src="media/15882113259367.jpg" alt="-w524"></p>
<h2 id="I-O流的分类"><a href="#I-O流的分类" class="headerlink" title="I/O流的分类"></a>I/O流的分类</h2><ul>
<li>从流的方向划分</li>
</ul>
<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
<ul>
<li>从流的分工划分</li>
</ul>
<ul>
<li>节点流</li>
<li>处理流</li>
</ul>
<ul>
<li>从流的内容划分</li>
</ul>
<ul>
<li>面向字符的流</li>
<li>面向字节的流</li>
</ul>
<p><strong><em>自己补充了解：</em></strong><br>节点流和处理流的区别<br><img src="media/15882115576182.jpg" alt="-w568"></p>
<h2 id="java-io-包的顶级层次结构"><a href="#java-io-包的顶级层次结构" class="headerlink" title="java.io 包的顶级层次结构"></a>java.io 包的顶级层次结构</h2><p>面向字符的流： 专门用于字符数据<br>面向字节的流： 用于一般目的<br><img src="media/15882126043831.jpg" alt="-w586"></p>
<h2 id="面向字符的流"><a href="#面向字符的流" class="headerlink" title="面向字符的流"></a>面向字符的流</h2><ul>
<li>针对字符数据的特点进行过优化，提供一些面向字符的有用特性</li>
<li>源或目标通常是文本文件<h3 id="实现内部格式和文本文件中的外部格式之间的转换"><a href="#实现内部格式和文本文件中的外部格式之间的转换" class="headerlink" title="实现内部格式和文本文件中的外部格式之间的转换"></a>实现内部格式和文本文件中的外部格式之间的转换</h3><img src="media/15882130366292.jpg" alt="-w684"><h3 id="面向字符的抽象类Read和Writer"><a href="#面向字符的抽象类Read和Writer" class="headerlink" title="面向字符的抽象类Read和Writer"></a>面向字符的抽象类Read和Writer</h3></li>
<li>java.io包中所有流的抽象基类</li>
<li>Reader提供了输入字符的API</li>
<li>Writer提供了输出字符的API</li>
<li>它们的子类又分为两大类</li>
</ul>
<ul>
<li>节点流： 从数据源读入数据或往目的地写出数据</li>
<li>处理流： 对数据执行某种处理</li>
</ul>
<ul>
<li>多数程序使用这两个抽象类的一系列子类来读入/写出文本信息</li>
</ul>
<ul>
<li>例如： FileRader/FileWriter用来读写文本文件</li>
</ul>
<p>处理流和节点流一览：<br><img src="media/15882256079774.jpg" alt="-w670"></p>
<h2 id="面向字节的流"><a href="#面向字节的流" class="headerlink" title="面向字节的流"></a>面向字节的流</h2><ul>
<li>数据源或目标中含有非字符数据，必须用字节流来输入/输出。</li>
<li>通常被用来读写诸如图片、声音之类的二进制数据</li>
<li>绝大多数数据是被存储为二进制文件的，世界上的文本大约只能占到2%，通常二进制文件比含有相同数据量的文本文件小得多。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/30/Java/Java-%E9%83%91%E8%8E%89%E7%89%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%AF%BE%E4%BB%B6/" data-id="ckb0u8ch8001vqgub7buwbrks" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/java-抽象类和接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/Java/java-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2020-04-16T00:48:24.569Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/Java/java-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">Java/java-抽象类和接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>要点提示： 父类中定义了相关子类的共同行为。接口可以拥有定义类的共同行为(包括非相关的类)</p>
<h2 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h2><p>要点提示： 抽象类不可以用于创建对象。抽象类可以包含抽象方法，这些方法将在具体的子类中实现。</p>
<ul>
<li><p>抽象类定义： 类的设计应该确保父类包含它的子类的共同特征。有时候，一个父类设计得非常抽象，以至于它都没任何具体的实例。这样的类称为抽象类。</p>
</li>
<li><p>抽象方法：<br><img src="media/15869985945845.jpg" alt="-w1084"></p>
</li>
<li><p>抽象类和常规类很像，但是不能使用new操作符创建它的实例。抽象方法只有定义而没有实现。他的实现由子类实现。一个包含对象方法的类的必须声明为抽象类。</p>
</li>
<li><p>抽象类的沟造方法定义为protected，它只能被子类使用。创建一个具体的子类的实例时，它的父类的构造方法被调用以初始化父类中定义的数据域。</p>
</li>
</ul>
<h3 id="为何要使用抽象方法"><a href="#为何要使用抽象方法" class="headerlink" title="为何要使用抽象方法"></a>为何要使用抽象方法</h3><p>使用抽象方法以后，JVM在运行时可以根据对象的类型动态地决定调用哪一个方法。</p>
<h3 id="抽象类的几点说明"><a href="#抽象类的几点说明" class="headerlink" title="抽象类的几点说明"></a>抽象类的几点说明</h3><ul>
<li>抽象方法不能包含在非抽象类中。如果抽象父类的子类不能实现所有的抽象方法，那么子类也必须定义为抽象的。即在抽象类扩展的非抽象子类中，必须实现所有的抽象方法。另外，抽象方法是<em>非静态</em>的。</li>
<li>抽象类不能使用new关键字来初始化。但是仍然可以定义它的构造方法，这个构造方法在它的子类的构造方法中调用。</li>
<li>抽象方法的类必须是抽象的。但是，可以定义一个不包含抽象方法的抽象类。这种情况下，不能使用new创建该类的实例。这种类是用来定义新子类的基类的。</li>
<li>子类可以覆盖分类的方法并将它定义为abstract。</li>
<li>即使子类的父类是具体的，这个子类也可以是抽象的。</li>
<li>不能使用new从一个抽象类创建一个实例。但是抽象类可以用作一种数据类型。<br>下面语句用来创建一个元素是GeometricObject类型的数组：<br>GeometricObject[] objects = new GeometricObject[10];<br>然后可以创建一个GeometricObject的实例，并将它的引用赋值给数组。<br>object[0] = new Circle();// Circle是GeometricObject的子类</li>
</ul>
<h2 id="示例学习：-抽象的Number类"><a href="#示例学习：-抽象的Number类" class="headerlink" title="示例学习： 抽象的Number类"></a>示例学习： 抽象的Number类</h2><p>要点提示： Number类是数值包装类、BigInteger以及BigDecimal的父类。</p>
<h2 id="示例学习：-Calendar和GregorianCalendar"><a href="#示例学习：-Calendar和GregorianCalendar" class="headerlink" title="示例学习： Calendar和GregorianCalendar"></a>示例学习： Calendar和GregorianCalendar</h2><p>要点提示： GregorianCalendar是抽象类Calendar的一个具体子类。</p>
<p>一个Date的实例表示以毫秒为精度的特定时刻。Calendar是一个抽象的基类，可以提取出详细的日历信息。例如： 年、月、日、小时、分钟和秒。<br>GregorianCalendar是一个支持公历的类。<br>Calendar类中的add方法是抽象的，因为它的实现依赖于某个具体的日历系统。</p>
<p>可以使用new GregorianCalendar()利用当前时间构造一个默认的GregorianCalendar对象，可以使用GregorianCalendar(year, month, date)利用指定的year、month和date(日)构造一个GregorianCalendar对象。参数month是基于0的，即0代表1月</p>
<p>在Calendar类中定义的get(int field)方法在从Calendar类中提取日期和时间信息方面是很有用的。日期和时间域都被定义为常量。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>要点提示： 接口是一种与类相似的结构，只包含常量和抽象方法</p>
<p>接口在很多方面都与抽象类很相似，但是它的目的是指明相关或者不相关类的多个对象的共同行为。例如，使用正确的接口，可以指明这些对象是可比较的、可食用的，以及可克隆的。<br>定义接口：<br><img src="media/15870270601472.jpg" alt="-w975"></p>
<p>在java中，接口被看作是一种特殊的类。就像常规类一样，每个接口都被编译为独立的字节码文件。使用接口或多或少有点像使用抽象类。即：</p>
<ul>
<li>可以使用接口作为引用变量的数据类型或类型转换的结果。</li>
<li>不能使用new操作符创建接口的实例。</li>
</ul>
<p>可以使用Edible接口来明确一个对象是否是可食用的。这需要使用implements关键字让对象的类实现这个接口来完成。</p>
<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>要点提示： Comparable接口定义了compoareTo方法，用于比较对象。<br>接口的定义如下：<br>// Interface for comparing objects, defined in java.lang<br>package java.lang;<br>public interface Comparable<E><br>{ public int compareTo(E o);<br>}</p>
<p>Comparable 方法判断这个对象相对于给定对象o的<em>顺序</em>，并且当这个对象小于、等于或大于给定对象o时，分别返回负整数、0或正整数。</p>
<p>Comparable接口是一个泛型接口。在实现该接口时，泛型类型E被替换成一种具体的类型。</p>
<p>由于所有Comparable对象都有compareTo方法，如果对象是Comparable接口类型的实例的话，Java API中的java.util.Arrays.sort(Object[])方法就可以使用compareTo方法对数组中的对象进行比较和排序。</p>
<h2 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h2><p>要点提示： Cloneable接口给出了一个可克隆的对象。</p>
<p>经常会出现需要创建一个对象拷贝的情况。为了实现这个目的，需要使用clone方法并理解Cloneable接口。</p>
<p>接口通常包括常量和抽象方法，但是Cloneable接口是一个特殊情况。在java.lang包中的Cloneable接口的定义如下：<br>package java.lang;<br>public interface Cloneable {<br>}</p>
<p>也就是说，这个接口是空的。<br>一个带空体的接口被称为标记接口(maker interface).一个标记接口及不包括常量也不包括方法。它用来表示一个类拥有某种特定的属性。实现Cloneable接口的类标记为可克隆的，而且它的对象可以使用在Object类中定义的clone()类方法。</p>
<p>Java库中的很多类（例如，Date、Calendar和ArrayList）实现Cloneable。这样这些类的实例可以被克隆。</p>
<p>为了定义一个自定义类来实现Cloneable接口，这个类必须覆盖Object类中的clone()方法。</p>
<h3 id="浅复制、-深复制"><a href="#浅复制、-深复制" class="headerlink" title="浅复制、 深复制"></a>浅复制、 深复制</h3><p>意思是：<br>Object类中的clone方法将原始对象的每个数据域赋值给目标对象。如果一个数据域是基本类型，复制的就是它的值，例如，area(double 类型)的值从house1复制到house2.如果一个数据域是对象，复制的就只是该域的引用。例如，域whenBuilt是Date类，所以，它的引用被复制给house2。<br>因此，尽管，house1==house2为假，但是house1.whenBuilt==house2.whenBuilt为真。这称为浅复制(shallow copy)而不是深复制(deep copy),这意味着如果数据域是对象类型，那么复制的是对象的引用，而不是它的内容。</p>
<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>要点提示：一个类可以实现多个接口，但是只能继承一个父类。<br>接口的使用和抽象类的使用基本相似，但是，定义一个接口与定义一个抽象类有所不同。<br><img src="media/15870516633639.jpg" alt="-w1096"></p>
<p>利用关键字extands，接口可以继承其他接口。这样的接口称为子接口(subinterface)。</p>
<p>接口可以扩展其他接口而不是类。一个类可以扩展它的父类同时实现多个接口。</p>
<p>所有的类共享一个根类Object，但是接口没有共同的根。<em>与此类似，接口也可以定义一种类型。一个接口类型的变量可以引用实现该接口的类的实例</em>。如果一个类实现了一个接口，那么这个接口就类似于该类的一个父类。可以将接口当作一种数据类型使用，将接口类型的变量转换为它的子类，反过来也可以。</p>
<p>注意：类名是一个名词。接口名可以是形容词或者名词。</p>
<p>设计指南：<br><img src="media/15870522012115.jpg" alt="-w1131"></p>
<p>通常，推荐使用接口而非抽象类，因为接口可以定义非相关类共有的父类型。接口比类更灵活。</p>
<h2 id="实例学习：-Rational类"><a href="#实例学习：-Rational类" class="headerlink" title="实例学习： Rational类"></a>实例学习： Rational类</h2><p>设计一个Rational类，用于表示和处理有理数。</p>
<h2 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h2><p>要点提示： 类的设计原则有助于设计出合理的类</p>
<h3 id="内聚性"><a href="#内聚性" class="headerlink" title="内聚性"></a>内聚性</h3><p>类应该描述一个单一的实体，而所有的类操作应该在逻辑上互相配合，只吃一个一致的目的。</p>
<p>如果一个实体担负太多的职责，就应该按各自的职责分成几个类</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>遵循标准Java程序设计风格和命名习惯。为类、数据域和方法选取具有信息的名字。通常的风格是将数据声明至于构造方法之前，并且将构造方法置于方法之前。</p>
<p>选择名字要保持一致。给类似的操作选择不同的名字并非良好的实践。</p>
<p>一般来说，应该具有一致性地提供一个公共无参构造方法，用于构建默认实例。如果一个类不支持无参的构造方法，要用文档写出原因。如果没有显式定义构造方法，即假定有一个空方法体的公共默认无参构造方法。</p>
<p>如果不想用户创建类的对象，可以在类中声明一个私有的构造方法，Match类就是如此</p>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>一个类应该使用private修饰符隐藏其数据，以免用户直接访问它。这使类更易于维护。</p>
<p><strong>只在</strong>希望数据域可读的情况下，才提供get方法；也只希望数据域可更新的情况下，才提供set方法。</p>
<h3 id="清晰性"><a href="#清晰性" class="headerlink" title="清晰性"></a>清晰性</h3><p>类应该有一个很清晰的合约，从而易于解释和理解。</p>
<p>用户可以以各种不同组合、顺序，以及在各种环境中结合使用多个类。因此，在设计一个类时，这个类不应该限制用户如何以及何时使用该类；以一种方式设计属性，以容许用户按值的任何顺序和任何组合来设置；设计方法应该使得实现的功能与它们出现的顺序无关。</p>
<p>不应该声明一个来自其他数据域的数据域。<br>例如：<br><img src="media/15875645623585.jpg" alt="-w1122"></p>
<h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>类是为许多不同用户的使用而设计的。为了能在一个广泛的应用中使用，一个类应该通过属性和方法提供多种方案以适应用户的不同需求。</p>
<h3 id="实例和静态"><a href="#实例和静态" class="headerlink" title="实例和静态"></a>实例和静态</h3><p>依赖于类的具体实例的变量或方法必须是一个实例变量或方法。</p>
<p>如果一个变量被类的所有实例所共享，那就应该将它声明为静态的。</p>
<p>如果方法 不依赖于某个具体的实例，那就应该将它声明为静态方法。</p>
<p>应该总是使用类名(而不是引用变量)引用静态变量和方法，以增强可读性并避免错误。</p>
<p>不要从构造方法中传入参数初始化<em>静态</em>数据。最好使用set方法改变静态数据域。</p>
<p>实例和静态是面向对象程序设计不可或缺的部分。数据域或方法要么是实例的，要么是静态的。不要错误地忽视了静态数据域或方法。</p>
<p>构造方法永远都是实例方法，因为它是用来创建具体实例的。一个静态变量或方法可以从实例中调用，但是不能从静态方法中调用实例变量或方法。</p>
<h3 id="继承和聚合"><a href="#继承和聚合" class="headerlink" title="继承和聚合"></a>继承和聚合</h3><p>继承和聚合之间的差异，就是is-a(是一种)和has-a(具有)之间的关系。<br>这里解释一下后者：<br>人具有名字，因此，可以使用<em>聚合</em>来对Person类和Name类之间的关系建模。</p>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>接口和抽象类都可以用于为对象指定共同的行为。</p>
<p>如何决定是采用接口还是抽象类？<br>同常，比较强的is-a关系清晰地描述了父子关系，应该采用类的继承关系来建模。弱的is-a关系，也称为is-kind-of(是一类)关系，表明一个对象拥有某种属性。弱的is-a关系可以使用接口来建模。</p>
<p>接口比抽象类更灵活，因为一个子类只能继承一个父类，但是却可以实现任意个数的接口。然而，接口不能具有具体的方法。可以结合接口和抽象类的优点，创建一个接口，使用一个抽象类来实现它。可以视其方便使用接口或抽象类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/16/Java/java-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" data-id="ckb0u8chs002zqgub2yli2qlc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-有关重写的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/12/Java/Java-%E6%9C%89%E5%85%B3%E9%87%8D%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-04-12T10:25:11.513Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/12/Java/Java-%E6%9C%89%E5%85%B3%E9%87%8D%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/">Java/Java-有关重写的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="有关重写的问题"><a href="#有关重写的问题" class="headerlink" title="有关重写的问题"></a>有关重写的问题</h1><h2 id="重写和覆盖的关系"><a href="#重写和覆盖的关系" class="headerlink" title="重写和覆盖的关系"></a>重写和覆盖的关系</h2><p><strong>* 重写就是覆盖 *</strong></p>
<h3 id="需要注意的几点："><a href="#需要注意的几点：" class="headerlink" title="需要注意的几点："></a>需要注意的几点：</h3><ul>
<li>仅当实例方法是可访问时，它才能被覆盖。因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系。</li>
<li>与实例方法一样，静态方法也能被继承。但是，静态方法不能被覆盖。如果父类中定义的静态方法在子类中重新被定义，那么在父类中定义的静态方法将被禁藏。可以使用语法: 父类名.静态方法名(superClassName.staticMethodName)调用隐藏的静态方法。<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3>不允许在子类中的一个方法具有和它父类中的方法完全相同的方法签名，但是返回值类型不同。这样会导致语法错误。</li>
</ul>
<p>子类中与其父类中的方法同名但具有不同参数类型的方法被称为重载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/12/Java/Java-%E6%9C%89%E5%85%B3%E9%87%8D%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ckb0u8cha001xqgubdwm3coxh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-ArrayList类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/11/Java/Java-ArrayList%E7%B1%BB/" class="article-date">
  <time datetime="2020-04-11T06:04:19.112Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/11/Java/Java-ArrayList%E7%B1%BB/">Java/Java-ArrayList类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h1><p>要点提示：ArrayList 对象可以用于存储一个对象列表</p>
<h2 id="用数组存储对象"><a href="#用数组存储对象" class="headerlink" title="用数组存储对象"></a>用数组存储对象</h2><p>数组可以用于存储一个一组对象，但是这个数组一旦创建，它的大小就固定了。Java提供ArrayList类来存锤不限定个数的对象。</p>
<h2 id="ArrayList类-1"><a href="#ArrayList类-1" class="headerlink" title="ArrayList类"></a>ArrayList类</h2><p>ArrayList是一种泛型类，具有一个泛型类型E。创建一个ArrayList时，可以指定一个具体的类型来替换E。<br>ArrayList类详细：<br><img src="media/15865854188912.jpg" alt="-w1127"></p>
<p>创建一个ArrayList，并且将其引用赋值给变量cities。该ArrayList对象可以用于存储字符串。例如：<br>ArrayList<String> cities = new ArrayList<String>();</p>
<p>创建一个ArrayList并且将其引用赋值给变量dates。该ArrayList对象可以用于存储日期。<br>ArrayList<Date> dates = new ArrayList<Date>();</p>
<p><strong>* 更新说明 *</strong><br><img src="media/15865856170194.jpg" alt="-w1039"></p>
<h2 id="ArrayList和数组之间的异同"><a href="#ArrayList和数组之间的异同" class="headerlink" title="ArrayList和数组之间的异同"></a>ArrayList和数组之间的异同</h2><p><img src="media/15865871383307.jpg" alt="-w1171"><br><img src="media/15865871488543.jpg" alt="-w1169"></p>
<p>分别对数组和ArrayList进行排序：<br><img src="media/15865888719004.jpg" alt="-w1133"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/11/Java/Java-ArrayList%E7%B1%BB/" data-id="ckb0u8cgz001jqgubc3j97iyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java-对象转换和instanceof" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/11/Java/Java-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%92%8Cinstanceof/" class="article-date">
  <time datetime="2020-04-11T03:12:04.583Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/11/Java/Java-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%92%8Cinstanceof/">Java/Java-对象转换和instanceof</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-对象转换和instanceof"><a href="#Java-对象转换和instanceof" class="headerlink" title="Java-对象转换和instanceof"></a>Java-对象转换和instanceof</h1><p>要点提示：对象的引用可以类型转换为另外一种对象的引用，这称为对象转换。</p>
<h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>Object o = new Student();<br>Student类是Object类的一个子类</p>
<h3 id="向上转换-upcasting"><a href="#向上转换-upcasting" class="headerlink" title="向上转换(upcasting)"></a>向上转换(upcasting)</h3><p>总是可以将一个子类的实例转换为一个父类的变脸，称为向上转换，因为子类的实例永远是它的父类的实例。(不需要使用转换记号”(子类名)”)</p>
<h3 id="向下转换-downcasting"><a href="#向下转换-downcasting" class="headerlink" title="向下转换(downcasting)"></a>向下转换(downcasting)</h3><p>当把一个父类的实例转换为它的子类变量(称为向下转换)时，必须使用转换记号”(子类名)”进行显式转换，向编译器表明意图。</p>
<p>为使转换成功，必须确保要转换的对象是子类的一个实例。如果父类对象不是子类的一个实例，就会出现一个运行异常ClassCastException.</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 是java中的关键字</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>(A和B都是对象)<br>A instanceof B //用来确定A是不是B的一个实例</p>
<h3 id="⚠️"><a href="#⚠️" class="headerlink" title="⚠️"></a>⚠️</h3><p><strong>*注意 *</strong><br>对象成员访问运算符(.)优先于类型转换运算符。所以使用圆括号保证在点运算符(.)之前进行转换，例如：<br>((Circle)object).getArea();</p>
<p>另外，对基本类型值进行转换不同于对对象引用进行转换。转换基本类型值返回一个新的值，例如：<br>int age = 45;<br>byte newAge = (byte)age;// A new value is assigned to newAge</p>
<p>而转换一个对象引用不会创建一个新的对象。例如：<br>Object o = new Circle();<br>Circle c = (Circle)o; // No new object is created<br>现在，引用变量o和c指向同一个对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/11/Java/Java-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%92%8Cinstanceof/" data-id="ckb0u8ch3001rqgub0ez5eit1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java/Java_instanceof" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/09/Java/Java_instanceof/" class="article-date">
  <time datetime="2020-04-09T01:22:47.193Z" itemprop="datePublished">2020-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/09/Java/Java_instanceof/">Java/Java_instanceof</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="instanceof关键字用法"><a href="#instanceof关键字用法" class="headerlink" title="instanceof关键字用法"></a>instanceof关键字用法</h1><p>instanceof 是java的一个二元操作符，类似于==，&gt;,&lt;等操作符。<br>instanceof 是java的保留关键字，它的作用是测试它左边的对象是否是它右边的类的实例 ，返回boolean的数据类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.nianchu.space/2020/04/09/Java/Java_instanceof/" data-id="ckb0u8chb001zqgub9gaq5i3j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80%E4%BD%9C%E4%B8%9A/">C语言作业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lintcode%E5%88%B7%E9%A2%98/">Lintcode刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E8%AF%B4%EF%BC%88%E4%B8%80%EF%BC%89/">小说（一）</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E8%89%BA/">文艺</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab/" rel="tag">Matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Matlab/" style="font-size: 16.67px;">Matlab</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/03/Java/%E9%80%92%E5%BD%92/">Java/递归</a>
          </li>
        
          <li>
            <a href="/2020/06/01/HTML/21%E5%A4%A9%E5%AD%A6%E9%80%9AHTML+CSS+JavaScript%20Web%E5%BC%80%E5%8F%91/">HTML/21天学通HTML+CSS+JavaScript Web开发</a>
          </li>
        
          <li>
            <a href="/2020/06/01/HTML/HTML/">HTML/HTML</a>
          </li>
        
          <li>
            <a href="/2020/05/31/Java/%E4%BA%8C%E8%BF%9B%E5%88%B6IO/">Java/二进制IO</a>
          </li>
        
          <li>
            <a href="/2020/05/22/Java/JavaFx%20UI%E7%BB%84%E4%BB%B6%E5%92%8C%E5%A4%9A%E5%AA%92%E4%BD%93/">JavaFx UI组件和多媒体</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 nianchu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>